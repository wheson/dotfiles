snippet kyoupro
        #include <iostream>
        #include <cmath>
        #include <vector>
        #include <string>
        #include <map>
        #include <algorithm>
        #include <tuple>
        #include <set>
        #include <stack>
        #include <queue>
        #include <deque>
        #include <cstdio>
        #include <bitset>
        #include <limits.h>
        #define REP(i, n) for(LL i = 0;i < n;i++)
        #define REPR(i, n) for(LL i = n;i >= 0;i--)
        #define FOR(i, m, n) for(LL i = m;i < n;i++)
        #define FORR(i, m, n) for(LL i = m;i >= n;i--)
        #define SORT(v, n) sort(v, v+n);
        #define VSORT(v) sort(v.begin(), v.end());
        #define pb(a) push_back(a)
        #define all(x) (x).begin(),(x).end()
        #define INF (LL)1e15
        #define MOD 1000000007
        using namespace std;
        typedef long long LL;
        typedef pair<int, int> P;
        typedef pair<LL, LL> LP;
        typedef pair<int, P> PP;
        typedef pair<LL, LP> LPP;
        int dy[]={0, 0, 1, -1, 0};
        int dx[]={1, -1, 0, 0, 0};
        
        //#define int long long

        /*************** using variables ***************/
        ${1}
        /**********************************************/

        signed main(){
            
        }

snippet sosuu
        bool isprime(LL x){
            if(x == 2) return true;
            if(x < 2 || x % 2 == 0) return false;
            LL i = 3;
            LL sqrtx = sqrt(x);
            while(i <= sqrtx){
                if(x % i == 0) return false;
                i += 2;
            }
            return true;
        }
        // maxまでの素数をvectorに入れて返す
        vector<LL> eratos(LL max){
            vector<LL> primeVec;
            vector<bool> isprime;
            double sqrtmax = sqrt(max);
            isprime.resize(max + 1);
            isprime[0] = false; isprime[1] = false;
            FOR(i, 2, max + 1){
                isprime[i] = true;
            }
            FOR(i, 2, sqrtmax){
                if(isprime[i]){
                    for(int j = 0; i * (j + 2) < max + 1; ++j){
                        isprime[i * (j + 2)] = false;
                    }
                }
            }
            REP(i, max + 1){
                if(isprime[i])  primeVec.pb(i);
            }
            return primeVec;
        }
        ${1} 

snippet euclidean
alias lcm gcd
        LL euclidean(LL a, LL b){
            if(a < b) swap(a, b);
            LL r = a % b;
            while(r != 0){
                a = b;
                b = r;
                r = a % b;
            }

            return b;
        }

        LL gcd(LL a, LL b){
            return euclidean(a, b);
        }

        LL lcm(LL a, LL b){
            LL g = gcd(a, b);
            return a / g * b;
        }

snippet dijkstra
        struct Edge{
            long long cost;
            int to;
            Edge(int t, long long c){
                cost = c;
                to = t;
            }
            bool operator<(const Edge &e) const {
                return cost < e.cost;
            }
            bool operator>(const Edge &e) const {
                return cost > e.cost;
            }
        };

        class Dijkstra{
            private:
                bool is_dir = false; // 無向グラフ: false, 有向グラフ: true
                long long INFl = (long long)1e15;
                int array_size_of_cost;
                vector<vector<Edge>> adj; // adj[始点][動的配列で始点から伸びる枝]

            public:
                Dijkstra(int n, bool dir);
                vector<long long> cost;
                vector<int> prever;
                void add_edge(int f, int t, long long c);
                bool has_path(int t); // tに至るパスはあるか
                vector<int> get_shortest_path(int t);
                void run(int f);
        };

        Dijkstra::Dijkstra(int n, bool dir):
            is_dir(dir), 
            array_size_of_cost(n + 1),
            adj(vector<vector<Edge>>(array_size_of_cost)),
            cost(vector<long long>(array_size_of_cost)),
            prever(vector<int>(array_size_of_cost, -1))
        {
            fill(cost.begin(), cost.end(), INFl);
        }

        void Dijkstra::add_edge(int f, int t, long long c){
            adj[f].push_back(Edge(t, c));
            if(!is_dir) adj[t].push_back(Edge(f, c));
        }

        bool Dijkstra::has_path(int t){
            return cost[t] != INFl;
        }

        vector<int> Dijkstra::get_shortest_path(int t){
            vector<int> path;
            for(; t != -1; t = prever[t]) path.push_back(t);

            reverse(path.begin(), path.end());
            return path;
        }

        void Dijkstra::run(int first_state){
            using State = Edge; 
            priority_queue<State, vector<State>, greater<State>> pq;

            cost[first_state] = 0;
            pq.push(Edge(first_state, 0LL));

            while(!pq.empty()){
                State current_state = pq.top();
                pq.pop();

                if(cost[current_state.to] < current_state.cost) continue;

                for(int i = 0; i < adj[current_state.to].size(); i++){
                    State tmp = adj[current_state.to][i];

                    long long sum_cost = current_state.cost + tmp.cost;
                    if(cost[tmp.to] > sum_cost){
                        cost[tmp.to] = sum_cost;
                        prever[tmp.to] = current_state.to;
                        pq.push(Edge(tmp.to, cost[tmp.to]));
                    }
                }
            }
        }

snippet bellman_ford
alias bellman
        struct Edge{
            int to;
            long long cost;
            Edge(int to, long long cost) : to(to), cost(cost) {}
        };

        class BellmanFord{
            private:
                long long INFl = (long long)1e15;
                int array_size_of_cost;
                int node_num;
                vector<vector<Edge>> adj; // adj[始点][動的配列で始点から伸びる枝]
                vector<bool> negative; // negative[n] := nに到達するまでに負閉路があるか

            public:
                BellmanFord(int n);
                vector<long long> dist; // 最短経路
                void add_edge(int f, int t, long long c);
                void run(int f);
                bool get_negative(int n);
        };

        BellmanFord::BellmanFord(int n):
            array_size_of_cost(n + 1),
            node_num(n),
            adj(vector<vector<Edge>>(array_size_of_cost)),
            negative(array_size_of_cost),
            dist(vector<long long>(array_size_of_cost))
        {
            fill(dist.begin(), dist.end(), INFl);
            fill(negative.begin(), negative.end(), false);
        }

        void BellmanFord::add_edge(int f, int t, long long c){
            adj[f].push_back(Edge(t, c));
        }

        void BellmanFord::run(int first_node){
            dist[first_node] = 0;
            for(int loop = 0; loop < node_num - 1; loop++){
                for(int i = 0; i < node_num; i++){
                    for(const Edge& e : adj[i]){
                        if(dist[i] == INFl) continue;
                        if(dist[e.to] > dist[i] + e.cost){
                            dist[e.to] = dist[i] + e.cost;
                        }
                    }
                }
            }

            for(int loop = 0; loop < node_num; loop++){
                for(int i = 0; i < node_num; i++){
                    for(const Edge& e : adj[i]){
                        if(dist[i] == INFl) continue;
                        if(dist[e.to] > dist[i] + e.cost){
                            dist[e.to] = dist[i] + e.cost;
                            negative[e.to] = true;
                        }
                        if(negative[i] == true){
                            negative[e.to] = true;
                        }
                    }
                }
            }
        }

        bool BellmanFord::get_negative(int n){
            return negative[n];
        }

snippet mod
        LL change_div_mul_mod(LL divisor, LL mod_minus_2, LL mod){
            if(mod_minus_2 == 0) return 1;
                else if(mod_minus_2 % 2 == 0){
                LL d = change_div_mul_mod(divisor, mod_minus_2/2, mod);
                return (d * d) % mod;
            }else{
                return (divisor * change_div_mul_mod(divisor, mod_minus_2-1, mod)) % mod;
            }
        }
